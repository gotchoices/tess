# Installation Design

How tess integrates into a host project. Tess supports two installation methods — git submodule (standard) and symlink (alternative) — and a single init script that detects which is in use and does the right thing.

## Requirements

- Committing the host project must not commit tess contents
- Updating tess is opt-in (pull when you want)
- Getting the latest version of tess should be easy
- Checking out a project should make it visible that tess is used (and how to get it), but tess itself should not be packed into the project repo
- Must work on macOS, Linux and Windows with multiple developers

## Resulting Project Layout

After initialization, the host project looks like this:

```
my-project/
├── tess/                    # Submodule (standard) or symlink (alternative)
│   ├── agent-rules/
│   │   ├── tickets.md       # Canonical ticket workflow rules
│   │   └── root.md          # Tess section for project root AGENTS.md / CLAUDE.md
│   ├── scripts/
│   │   ├── init.mjs         # Project initialization
│   │   ├── run.mjs          # Ticket runner
│   │   └── detach.mjs       # Tess removal
│   └── ...
├── tickets/
│   ├── fix/
│   ├── plan/
│   ├── implement/
│   ├── review/
│   ├── complete/
│   ├── blocked/
│   ├── .logs/               # Git-ignored
│   ├── AGENTS.md            # Stub file (submodule) or symlink (symlink mode)
│   └── CLAUDE.md            # Stub file (submodule) or symlink (symlink mode)
├── AGENTS.md                # Project root — tess section added if missing
├── CLAUDE.md                # Project root — tess section added if missing
├── .gitmodules              # Present if using submodule method
└── ...
```

## Method 1: Git Submodule (Standard)

### What git submodules are

Git submodules let you embed one git repo inside another as a *pointer*, not a copy. The parent repo stores only a `.gitmodules` file (recording the URL and path) and a commit SHA (pinning the exact version). The submodule's actual file contents are not part of the parent's tree — they're fetched separately.

This was designed for exactly this scenario: "my project depends on this other repo, but I don't want to absorb its contents."

### Setup (one-time per project)

```bash
# From project root:
git submodule add <tess-repo-url> tess
node tess/scripts/init.mjs
git add .
git commit -m "add tess ticketing system"
```

### What `git submodule add` does

1. Clones tess into `tess/` as a nested git repo
2. Creates `.gitmodules` recording the URL and path
3. Records the exact commit hash of tess in the parent's index

The parent repo tracks only the pointer. `git status` in the parent will never show changes to files *inside* `tess/` — only whether the pointer SHA has changed.

### Cloning a project that uses tess

```bash
# Option A: clone with submodules in one step
git clone --recurse-submodules <project-url>

# Option B: clone first, then fetch submodules
git clone <project-url>
cd my-project
git submodule update --init
```

The `.gitmodules` file is visible in the repo, so anyone checking out the project can see that tess is a dependency and where to get it — even before fetching it.

### Updating tess

```bash
cd tess
git pull
cd ..
git add tess
git commit -m "update tess to latest"
```

Or the shorthand: `git submodule update --remote && git add tess && git commit -m "update tess"`.

Each project pins its own tess version and updates when ready.

### How init works in submodule mode

The init script detects that `tess/` is a submodule (see detection logic below) and:

1. **Creates the `tickets/` scaffold** — stage subdirectories (`fix/`, `plan/`, `implement/`, `review/`, `complete/`, `blocked/`), `.gitignore` for `.logs/`.

2. **Creates stub files in `tickets/`** — `AGENTS.md` and `CLAUDE.md` are small, real files (not symlinks) that reference the canonical rules:

   ```markdown
   <!-- Generated by tess init. Do not edit — see tess/agent-rules/tickets.md -->
   Read and follow the ticket workflow rules in [tess/agent-rules/tickets.md](../tess/agent-rules/tickets.md).
   ```

   This avoids symlinks entirely in submodule mode, eliminating Windows compatibility issues. Agents that discover these files via convention will follow the reference. The runner reads `tess/agent-rules/tickets.md` directly (it knows where it lives).

3. **Ensures root `AGENTS.md` and `CLAUDE.md` mention tess** — For each root convention file, the script checks whether it contains a `<!-- tess -->` marker. If not, it appends the contents of `tess/agent-rules/root.md` (which includes the marker). If no root file exists, the script creates one with just this section.

### Why stub files instead of symlinks (submodule mode)

- Cross-platform: no symlink issues on Windows
- No re-init needed after updating tess (stub content is a pointer, like the submodule itself)
- The runner reads `tess/agent-rules/tickets.md` directly — it doesn't go through the stub
- Ad-hoc agents discover the stub via convention and follow the file reference
- Stubs are tiny, stable, and committable

**Agent behavior dependency:** The stub files rely on agents following a markdown file reference to read the actual rules. This works for the runner (which reads rules directly) and for ad-hoc agent usage (Cursor, Claude Code, and Augment all follow explicit file references). If an agent only reads the stub literally, it gets a one-liner pointing to the rules — a graceful degradation rather than a failure.

## Method 2: Symlinks (Alternative)

### When to use

When you prefer not to use git submodules — e.g., tess is cloned as a sibling directory, or you have a personal workspace layout where submodules add friction.

### Setup

```bash
# Clone tess somewhere (e.g., sibling directory)
cd /path/to/devel
git clone <tess-repo-url> tess

# From project root:
node /path/to/devel/tess/scripts/init.mjs
```

### How init works in symlink mode

The init script detects that it's being run from an external path (tess is not inside the project) and:

1. **Creates a root symlink** — `tess` → relative path to the tess checkout. Uses a relative path so the link survives if the parent directory moves.

2. **Creates the `tickets/` scaffold** — same as submodule mode.

3. **Creates symlinks in `tickets/`** — `AGENTS.md` → `../tess/agent-rules/tickets.md`, `CLAUDE.md` → same target. These are real symlinks, so agents and the runner both see the actual content.

4. **Ensures root `AGENTS.md` and `CLAUDE.md` mention tess** — same as submodule mode.

5. **Updates `.gitignore`** — idempotently adds entries for the `tess` symlink and `tickets/AGENTS.md`, `tickets/CLAUDE.md` (since symlinks to external files shouldn't be committed). Checks for existing entries before adding to avoid duplicates.

### Updating tess (symlink mode)

```bash
cd /path/to/devel/tess
git pull
```

Changes take effect immediately — the symlinks point to the live checkout.

### Windows note

Symlinks on Windows require Developer Mode or elevated privileges and `core.symlinks=true` in git config. If symlinks aren't available, the init script can fall back to file copies with a warning that re-running init is needed after updating tess.

## Detection Logic

The init script determines the installation method automatically:

```
if (project_root/tess exists) {
    if (tess/.git is a file containing "gitdir:") → submodule mode
    if (tess is a symlink) → symlink mode
    else → plain directory — treat as submodule mode (log a note)
} else {
    // init.mjs was invoked from an external tess checkout
    → symlink mode (create root symlink first)
}
```

The script's own location (`import.meta.url`) tells it where the tess checkout is. The cwd (or `--project` argument) tells it where the host project is.

Note on the "plain directory" case: if someone manually copies tess into their project (rather than using a submodule or symlink), init treats it as submodule mode (stub files, no symlinks). This works correctly but the user loses the update mechanism. The script should log a message suggesting `git submodule add` instead.

## Runner Invocation

In both modes, tess appears at `project_root/tess/`, so the runner is always invoked the same way:

```bash
node tess/scripts/run.mjs [options]
```

The runner resolves paths relative to cwd:
- `tickets/` — where ticket files live (cwd-relative)
- `tess/agent-rules/tickets.md` — canonical rules (runner knows its own location via `import.meta.url`)

## Ignoring Ticket Stage Folders

By default, ticket stage folders (`fix/`, `plan/`, `implement/`, `review/`, `complete/`, `blocked/`) are tracked in git so the whole team shares a single ticket pipeline. However, some teams prefer each developer to maintain their own tickets locally — in that case, stage folders should be git-ignored.

The init script handles this with a prompt or CLI flags:

- **Interactive (default):** When neither flag is passed, init asks: `Add ticket stage folders to .gitignore? [y/N]`. The default answer is **No** (stage folders are tracked).
- **`--ignore-stages`:** Adds all stage folder names to `tickets/.gitignore` without prompting.
- **`--no-ignore-stages`:** Skips adding them without prompting.

When stage folders are ignored, `tickets/.gitignore` will contain entries like `fix/`, `plan/`, etc. alongside the existing `.logs/` entry. Re-running init with `--ignore-stages` on an existing project will idempotently add any missing entries.

## Init Script: Idempotent and Non-Destructive

The init script is safe to re-run at any time:
- Creates directories only if they don't exist
- Creates stub/symlink files only if they don't exist (never overwrites)
- Appends to root `AGENTS.md` only if a tess section isn't already present
- Idempotently adds gitignore entries for stage folders when `--ignore-stages` is used
- Can be used to "refresh" after updating tess (in symlink mode, symlinks don't need refreshing; in submodule mode, stubs don't need refreshing since they're pointers)

## Comparison Summary

| Concern | Submodule | Symlink |
|---|---|---|
| Platform | All | macOS/Linux (Windows needs Developer Mode) |
| Committing project | Only commits tess pointer (SHA) | tess symlink is gitignored |
| Visibility to collaborators | `.gitmodules` shows tess dependency | Not visible — needs documentation |
| Updating tess | `git submodule update --remote` | `cd tess && git pull` |
| Clone setup | `--recurse-submodules` or `git submodule update --init` | Clone tess separately, run init |
| Files in `tickets/` | Real stub files (committable) | Symlinks (gitignored) |
| Re-init after tess update | Not needed for content; re-run for structural changes | Not needed (symlinks are live) |

## Removing Tess

Run `node tess/scripts/detach.mjs` from the project root. This removes tess-created artifacts without touching the `tickets/` directory or its contents:

1. Removes `tickets/AGENTS.md` and `tickets/CLAUDE.md` (after verifying they're tess-created — checks for the `<!-- Generated by tess init -->` marker in stubs, or confirms they're symlinks pointing into tess)
2. Removes the `<!-- tess -->` section from root `AGENTS.md` and `CLAUDE.md`
3. In symlink mode: removes the `tess` symlink and cleans tess-related `.gitignore` entries
4. In submodule mode: prints the git commands to remove the submodule (doesn't execute them)

The detach script never deletes `tickets/` or any ticket files — that's the user's data.

---

## Version Management

Git submodules handle versioning natively. The parent repo's submodule pointer *is* the version record — it pins the exact tess commit SHA. Standard git tooling already surfaces mismatches: `git status` shows `tess` as modified if the local checkout differs from the committed pointer, and `git submodule status` prints the SHA with a `+` prefix when out of sync.

No custom version file or comparison logic is needed. The runner will print the current tess commit hash in its startup banner for quick visibility, but this is purely informational.

In symlink mode there's no submodule pointer, but the developer is explicitly managing their own tess checkout and knows what version they're on.
