#!/usr/bin/env node
/**
 * Tess detach script — removes tess-created artifacts from a host project
 * without touching the tickets/ directory or any ticket files.
 *
 * Usage:
 *   node tess/scripts/detach.mjs              # from project root
 *   node tess/scripts/detach.mjs --project /path/to/project
 *
 * What it removes:
 *   - tickets/AGENTS.md and tickets/CLAUDE.md (if tess-created)
 *   - The <!-- tess --> section from root AGENTS.md and CLAUDE.md
 *   - In symlink mode: the tess symlink and .gitignore entries
 *   - In submodule mode: prints git commands (doesn't execute them)
 *
 * What it never touches:
 *   - tickets/ directory and its contents (stage folders, ticket files)
 *   - Any file not created by tess init
 */

import { readFile, writeFile, unlink, lstat, readlink, access } from 'node:fs/promises';
import { join, dirname, resolve } from 'node:path';
import { fileURLToPath } from 'node:url';
import { constants } from 'node:fs';

// ─── Configuration ─────────────────────────────────────────────────────────────

const AGENT_RULE_NAMES = ['AGENTS.md', 'CLAUDE.md'];

const TESS_STUB_MARKER = '<!-- Generated by tess init';
const TESS_SECTION_MARKER = '<!-- tess -->';

// ─── Helpers ───────────────────────────────────────────────────────────────────

function log(msg) { console.log(`  ${msg}`); }
function warn(msg) { console.warn(`  ⚠ ${msg}`); }

async function exists(path) {
	try { await access(path, constants.F_OK); return true; } catch { return false; }
}

async function isSymlink(path) {
	try { const s = await lstat(path); return s.isSymbolicLink(); } catch { return false; }
}

async function isFile(path) {
	try { const s = await lstat(path); return s.isFile(); } catch { return false; }
}

async function readTextOrEmpty(path) {
	try { return await readFile(path, 'utf-8'); } catch { return ''; }
}

// ─── Detach steps ──────────────────────────────────────────────────────────────

async function removeTicketsRuleFiles(projectRoot) {
	const ticketsDir = join(projectRoot, 'tickets');

	for (const name of AGENT_RULE_NAMES) {
		const filePath = join(ticketsDir, name);

		if (!await exists(filePath)) continue;

		if (await isSymlink(filePath)) {
			const target = await readlink(filePath);
			if (target.includes('tess')) {
				await unlink(filePath);
				log(`Removed symlink: tickets/${name}`);
			} else {
				warn(`tickets/${name} is a symlink but doesn't point to tess — skipping`);
			}
			continue;
		}

		const content = await readTextOrEmpty(filePath);
		if (content.includes(TESS_STUB_MARKER)) {
			await unlink(filePath);
			log(`Removed stub: tickets/${name}`);
		} else {
			warn(`tickets/${name} doesn't appear to be tess-created — skipping`);
		}
	}
}

async function removeTessSectionFromRootFiles(projectRoot) {
	for (const name of AGENT_RULE_NAMES) {
		const filePath = join(projectRoot, name);
		const content = await readTextOrEmpty(filePath);

		if (!content || !content.includes(TESS_SECTION_MARKER)) continue;

		const markerIdx = content.indexOf(TESS_SECTION_MARKER);

		// Find the start of the tess section — include any blank lines before the marker
		let sectionStart = markerIdx;
		while (sectionStart > 0 && content[sectionStart - 1] === '\n') {
			sectionStart--;
		}

		// The tess section runs from the marker to either the next <!-- marker
		// or the end of the file
		const afterMarker = content.indexOf('\n<!--', markerIdx + TESS_SECTION_MARKER.length);
		const sectionEnd = afterMarker !== -1 ? afterMarker : content.length;

		const before = content.slice(0, sectionStart);
		const after = content.slice(sectionEnd);
		const result = (before + after).trim();

		if (result.length === 0) {
			await unlink(filePath);
			log(`Removed ${name} (was tess-only content)`);
		} else {
			await writeFile(filePath, result + '\n', 'utf-8');
			log(`Removed tess section from ${name}`);
		}
	}
}

async function handleSymlinkMode(projectRoot) {
	const tessLink = join(projectRoot, 'tess');

	if (await isSymlink(tessLink)) {
		await unlink(tessLink);
		log('Removed tess symlink');
	}

	// Clean .gitignore entries
	const gitignorePath = join(projectRoot, '.gitignore');
	const content = await readTextOrEmpty(gitignorePath);
	if (!content) return;

	const tessEntries = new Set(['tess', ...AGENT_RULE_NAMES.map(n => `tickets/${n}`)]);
	const lines = content.split('\n');
	const filtered = lines.filter(line => !tessEntries.has(line.trim()));

	if (filtered.length !== lines.length) {
		const result = filtered.join('\n').replace(/\n{3,}/g, '\n\n').trim();
		if (result.length === 0) {
			await unlink(gitignorePath);
			log('Removed .gitignore (was tess-only content)');
		} else {
			await writeFile(gitignorePath, result + '\n', 'utf-8');
			log('Cleaned tess entries from .gitignore');
		}
	}
}

async function handleSubmoduleMode(projectRoot) {
	console.log('\n  To remove the tess submodule, run:\n');
	console.log('    git submodule deinit -f tess');
	console.log('    git rm tess');
	console.log('    rm -rf .git/modules/tess');
	console.log('    git commit -m "remove tess"\n');
}

// ─── Detection ─────────────────────────────────────────────────────────────────

async function detectMode(projectRoot) {
	const tessInProject = join(projectRoot, 'tess');

	if (await isSymlink(tessInProject)) return 'symlink';

	if (await exists(tessInProject)) {
		const dotGitPath = join(tessInProject, '.git');
		if (await isFile(dotGitPath)) {
			const content = await readTextOrEmpty(dotGitPath);
			if (content.includes('gitdir:')) return 'submodule';
		}
	}

	return 'unknown';
}

// ─── CLI ───────────────────────────────────────────────────────────────────────

function parseArgs(argv) {
	const opts = { projectRoot: process.cwd() };
	for (let i = 0; i < argv.length; i++) {
		if (argv[i] === '--project' && argv[i + 1]) {
			opts.projectRoot = resolve(argv[++i]);
		} else if (argv[i] === '--help') {
			console.log([
				'Tess detach — remove tess artifacts from a project',
				'',
				'Usage:',
				'  node tess/scripts/detach.mjs',
				'  node tess/scripts/detach.mjs --project /path/to/project',
				'',
				'Removes tess-created files. Never deletes tickets/ or ticket files.',
			].join('\n'));
			process.exit(0);
		}
	}
	return opts;
}

// ─── Main ──────────────────────────────────────────────────────────────────────

async function main() {
	const opts = parseArgs(process.argv.slice(2));
	const projectRoot = opts.projectRoot;
	const mode = await detectMode(projectRoot);

	console.log(`\nTess detach — project: ${projectRoot}`);
	console.log(`              mode:    ${mode}\n`);

	// Step 1: Remove tickets/AGENTS.md and tickets/CLAUDE.md
	await removeTicketsRuleFiles(projectRoot);

	// Step 2: Remove tess section from root convention files
	await removeTessSectionFromRootFiles(projectRoot);

	// Step 3: Mode-specific cleanup
	if (mode === 'symlink') {
		await handleSymlinkMode(projectRoot);
	} else if (mode === 'submodule') {
		await handleSubmoduleMode(projectRoot);
	}

	console.log('Done.\n');
}

main().catch((err) => {
	console.error('Tess detach failed:', err);
	process.exit(1);
});
