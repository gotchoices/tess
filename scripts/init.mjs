#!/usr/bin/env node
/**
 * Tess project initialization script.
 *
 * Detects how tess is installed (git submodule or symlink) and sets up the
 * tickets/ scaffold and agent-rules references in the host project.
 *
 * Usage:
 *   node tess/scripts/init.mjs              # from project root (submodule mode)
 *   node /path/to/tess/scripts/init.mjs     # from project root (symlink mode)
 *   node tess/scripts/init.mjs --project /path/to/project
 *
 * Idempotent and non-destructive — safe to re-run at any time.
 */

import { readFile, writeFile, mkdir, symlink, lstat, readlink, access } from 'node:fs/promises';
import { join, dirname, relative, resolve } from 'node:path';
import { fileURLToPath } from 'node:url';
import { constants } from 'node:fs';

// ─── Configuration ─────────────────────────────────────────────────────────────

const AGENT_RULE_NAMES = ['AGENTS.md', 'CLAUDE.md'];

const TICKET_STAGES = ['fix', 'plan', 'implement', 'review', 'complete', 'blocked'];

const TICKETS_GITIGNORE = '.logs/\n';

const STUB_CONTENT = `<!-- Generated by tess init. Do not edit — see tess/agent-rules/tickets.md -->\nRead and follow the ticket workflow rules in [tess/agent-rules/tickets.md](../tess/agent-rules/tickets.md).\n`;

// ─── Helpers ───────────────────────────────────────────────────────────────────

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const TESS_ROOT = resolve(__dirname, '..');

function log(msg) { console.log(`  ${msg}`); }
function warn(msg) { console.warn(`  ⚠ ${msg}`); }

async function exists(path) {
	try { await access(path, constants.F_OK); return true; } catch { return false; }
}

async function isSymlink(path) {
	try { const s = await lstat(path); return s.isSymbolicLink(); } catch { return false; }
}

async function isFile(path) {
	try { const s = await lstat(path); return s.isFile(); } catch { return false; }
}

async function readTextOrEmpty(path) {
	try { return await readFile(path, 'utf-8'); } catch { return ''; }
}

async function writeIfMissing(path, content, label) {
	if (await exists(path)) {
		log(`${label} already exists, skipping`);
		return false;
	}
	await writeFile(path, content, 'utf-8');
	log(`Created ${label}`);
	return true;
}

async function ensureDir(path, label) {
	await mkdir(path, { recursive: true });
}

async function addGitignoreEntry(gitignorePath, entry) {
	const content = await readTextOrEmpty(gitignorePath);
	if (content.split('\n').some(line => line.trim() === entry.trim())) {
		return false;
	}
	const separator = content.length > 0 && !content.endsWith('\n') ? '\n' : '';
	await writeFile(gitignorePath, content + separator + entry + '\n', 'utf-8');
	return true;
}

// ─── Detection ─────────────────────────────────────────────────────────────────

/**
 * Determine installation mode.
 * Returns { mode: 'submodule' | 'symlink', needsRootSymlink: boolean }
 */
async function detectMode(projectRoot) {
	const tessInProject = join(projectRoot, 'tess');

	if (await exists(tessInProject)) {
		if (await isSymlink(tessInProject)) {
			log('Detected: tess is a symlink');
			return { mode: 'symlink', needsRootSymlink: false };
		}

		const dotGitPath = join(tessInProject, '.git');
		if (await isFile(dotGitPath)) {
			const content = await readTextOrEmpty(dotGitPath);
			if (content.includes('gitdir:')) {
				log('Detected: tess is a git submodule');
				return { mode: 'submodule', needsRootSymlink: false };
			}
		}

		warn('tess/ exists but is not a submodule or symlink — treating as submodule mode');
		return { mode: 'submodule', needsRootSymlink: false };
	}

	// tess not in project — running from external path, symlink mode
	log('tess not found in project — will create symlink');
	return { mode: 'symlink', needsRootSymlink: true };
}

// ─── Init steps ────────────────────────────────────────────────────────────────

async function createRootSymlink(projectRoot) {
	const target = relative(projectRoot, TESS_ROOT);
	const linkPath = join(projectRoot, 'tess');

	try {
		await symlink(target, linkPath, 'dir');
		log(`Created symlink: tess → ${target}`);
	} catch (err) {
		if (err.code === 'EPERM' || err.code === 'EACCES') {
			console.error('\nFailed to create symlink (permission denied).');
			console.error('On Windows, enable Developer Mode or run as administrator.');
			process.exit(1);
		}
		throw err;
	}
}

async function createTicketsScaffold(projectRoot) {
	const ticketsDir = join(projectRoot, 'tickets');

	for (const stage of TICKET_STAGES) {
		await ensureDir(join(ticketsDir, stage));
	}
	log('Ensured tickets/ stage directories');

	await ensureDir(join(ticketsDir, '.logs'));

	await writeIfMissing(
		join(ticketsDir, '.gitignore'),
		TICKETS_GITIGNORE,
		'tickets/.gitignore',
	);
}

async function createTicketsStubs(projectRoot) {
	const ticketsDir = join(projectRoot, 'tickets');

	for (const name of AGENT_RULE_NAMES) {
		await writeIfMissing(
			join(ticketsDir, name),
			STUB_CONTENT,
			`tickets/${name}`,
		);
	}
}

async function createTicketsSymlinks(projectRoot) {
	const ticketsDir = join(projectRoot, 'tickets');
	const target = join('..', 'tess', 'agent-rules', 'tickets.md');

	for (const name of AGENT_RULE_NAMES) {
		const linkPath = join(ticketsDir, name);
		if (await exists(linkPath)) {
			log(`tickets/${name} already exists, skipping`);
			continue;
		}
		try {
			await symlink(target, linkPath, 'file');
			log(`Created symlink: tickets/${name} → ${target}`);
		} catch (err) {
			if (err.code === 'EPERM' || err.code === 'EACCES') {
				warn(`Symlink failed for tickets/${name} — falling back to stub file`);
				await writeFile(linkPath, STUB_CONTENT, 'utf-8');
				log(`Created stub: tickets/${name} (symlink fallback)`);
			} else {
				throw err;
			}
		}
	}
}

async function ensureRootAgentRules(projectRoot) {
	const rootSection = await readFile(join(TESS_ROOT, 'agent-rules', 'root.md'), 'utf-8');

	for (const name of AGENT_RULE_NAMES) {
		const filePath = join(projectRoot, name);
		const existing = await readTextOrEmpty(filePath);

		if (existing.includes('<!-- tess -->')) {
			log(`${name} already has tess section, skipping`);
			continue;
		}

		const separator = existing.length > 0 && !existing.endsWith('\n') ? '\n\n' : existing.length > 0 ? '\n' : '';
		await writeFile(filePath, existing + separator + rootSection, 'utf-8');
		log(existing.length > 0 ? `Appended tess section to ${name}` : `Created ${name}`);
	}
}

async function updateGitignoreForSymlinks(projectRoot) {
	const gitignorePath = join(projectRoot, '.gitignore');
	const entries = ['tess', ...AGENT_RULE_NAMES.map(n => `tickets/${n}`)];

	let added = false;
	for (const entry of entries) {
		if (await addGitignoreEntry(gitignorePath, entry)) {
			added = true;
		}
	}
	if (added) {
		log('Updated .gitignore with tess symlink entries');
	} else {
		log('.gitignore already has tess entries, skipping');
	}
}

// ─── CLI ───────────────────────────────────────────────────────────────────────

function parseArgs(argv) {
	const opts = { projectRoot: process.cwd() };
	for (let i = 0; i < argv.length; i++) {
		if (argv[i] === '--project' && argv[i + 1]) {
			opts.projectRoot = resolve(argv[++i]);
		} else if (argv[i] === '--help') {
			console.log([
				'Tess project initialization',
				'',
				'Usage:',
				'  node tess/scripts/init.mjs              # submodule mode',
				'  node /path/to/tess/scripts/init.mjs     # symlink mode',
				'  node tess/scripts/init.mjs --project /path/to/project',
				'',
				'Idempotent — safe to re-run at any time.',
			].join('\n'));
			process.exit(0);
		}
	}
	return opts;
}

// ─── Main ──────────────────────────────────────────────────────────────────────

async function main() {
	const opts = parseArgs(process.argv.slice(2));
	const projectRoot = opts.projectRoot;

	console.log(`\nTess init — project: ${projectRoot}`);
	console.log(`            tess:    ${TESS_ROOT}\n`);

	// Verify tess has the expected structure
	const rulesFile = join(TESS_ROOT, 'agent-rules', 'tickets.md');
	if (!await exists(rulesFile)) {
		console.error(`Cannot find ${rulesFile} — is this a valid tess checkout?`);
		process.exit(1);
	}

	const { mode, needsRootSymlink } = await detectMode(projectRoot);

	// Step 1: Create root symlink if needed (symlink mode only)
	if (needsRootSymlink) {
		await createRootSymlink(projectRoot);
	}

	// Step 2: Create tickets/ scaffold
	await createTicketsScaffold(projectRoot);

	// Step 3: Create agent-rule references in tickets/
	if (mode === 'submodule') {
		await createTicketsStubs(projectRoot);
	} else {
		await createTicketsSymlinks(projectRoot);
	}

	// Step 4: Ensure root AGENTS.md / CLAUDE.md have tess section
	await ensureRootAgentRules(projectRoot);

	// Step 5: Update .gitignore (symlink mode only)
	if (mode === 'symlink') {
		await updateGitignoreForSymlinks(projectRoot);
	}

	console.log('\nDone.\n');
}

main().catch((err) => {
	console.error('Tess init failed:', err);
	process.exit(1);
});
